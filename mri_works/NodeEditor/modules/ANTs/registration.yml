antsRegistration:
  version: '' # Get Version Information. 
  dimensionality: '' # 2/3. This option forces the image to be treated as a specified-dimensional image. If not specified, we try to infer the dimensionality from the input image. 
  save-state: '' # saveSateAsTransform
                 # A boolean specifying whether or not the composite transform resulted from the 
                 # current state of the registration should be written to an hdf5 composite file. 
                 # It is specially usefull if we want to save the current state of a SyN 
                 # registration to the disk, so we can load and restore that later to continue the 
                 # next registration directly started from the same state that it was stored. The 
                 # output of this flag will be the same as the write-composite-transform, unless 
                 # the last transform is a SyN transform. In that case, the inverse displacement 
                 # field of the SyN transform is also added to the output composite transform. To 
                 # load the written file this flag, we must use restore-state. 
  restore-state: '' # restoreStateAsATransform
                    # Specify the initial state of the registration which get immediately used to 
                    # directly initialize the registration process. The flag is mutually exclusive 
                    # with other intialization flags.If this flag is used, none of the 
                    # initial-moving-transform and initial-fixed-transform cannot be used. 
  write-composite-transform: '' # 1/(0)
                                # Boolean specifying whether or not the composite transform (and its inverse, if 
                                # it exists) should be written to an hdf5 composite file. This is false by default 
                                # so that only the transform for each stage is written to file. 
                                # <VALUES>: 0
  print-similarity-measure-interval: '' # <unsignedIntegerValue>
                                        # Prints out the CC similarity metric measure between the full-size input fixed 
                                        # and the transformed moving images at each iteration a value of 0 (the default) 
                                        # indicates that the full scale computation should not take placeany value greater 
                                        # than 0 represents the interval of full scale metric computation. 
                                        # <VALUES>: 0
  write-interval-volumes: '' # <unsignedIntegerValue>
                             # Writes out the output volume at each iteration. It helps to present the 
                             # registration process as a short movie a value of 0 (the default) indicates that 
                             # this option should not take placeany value greater than 0 represents the 
                             # interval between the iterations which outputs are written to the disk. 
                             # <VALUES>: 0
  collapse-output-transforms: '' # (1)/0
                                 # Collapse output transforms. Specifically, enabling this option combines all 
                                 # adjacent transforms wherepossible. All adjacent linear transforms are written to 
                                 # disk in the forman itk affine transform (called xxxGenericAffine.mat). 
                                 # Similarly, all adjacent displacement field transforms are combined when written 
                                 # to disk (e.g. xxxWarp.nii.gz and xxxInverseWarp.nii.gz (if available)).Also, an 
                                 # output composite transform including the collapsed transforms is written to the 
                                 # disk (called outputCollapsed(Inverse)Composite). 
                                 # <VALUES>: 1
  initialize-transforms-per-stage: '' # (1)/0
                                      # Initialize linear transforms from the previous stage. By enabling this option, 
                                      # the current linear stage transform is directly intialized from the previous 
                                      # stage's linear transform; this allows multiple linear stages to be run where 
                                      # each stage directly updates the estimated linear transform from the previous 
                                      # stage. (e.g. Translation -> Rigid -> Affine). 
                                      # <VALUES>: 0
  interpolation: '' # Linear
                    # NearestNeighbor
                    # MultiLabel[<sigma=imageSpacing>,<alpha=4.0>]
                    # Gaussian[<sigma=imageSpacing>,<alpha=1.0>]
                    # BSpline[<order=3>]
                    # CosineWindowedSinc
                    # WelchWindowedSinc
                    # HammingWindowedSinc
                    # LanczosWindowedSinc
                    # Several interpolation options are available in ITK. These have all been made 
                    # available. Currently the interpolator choice is only used to warp (and possibly 
                    # inverse warp) the final output image(s). 
  restrict-deformation: '' # PxQxR
                           # This option allows the user to restrict the optimization of the displacement 
                           # field, translation, rigid or affine transform on a per-component basis. For 
                           # example, if one wants to limit the deformation or rotation of 3-D volume to the 
                           # first two dimensions, this is possible by specifying a weight vector of '1x1x0' 
                           # for a deformation field or '1x1x0x1x1x0' for a rigid 
                           # transformation.Low-dimensional restriction only works if there are no preceding 
                           # transformations. 
  initial-fixed-transform: '' # initialTransform
                              # [initialTransform,<useInverse>]
                              # [fixedImage,movingImage,initializationFeature]
                              # Specify the initial fixed transform(s) which get immediately incorporated into 
                              # the composite transform. The order of the transforms is stack-esque in that the 
                              # last transform specified on the command line is the first to be applied. In 
                              # addition to initialization with ITK transforms, the user can perform an initial 
                              # translation alignment by specifying the fixed and moving images and selecting an 
                              # initialization feature. These features include using the geometric center of the 
                              # images (=0), the image intensities (=1), or the origin of the images (=2). 
  initial-moving-transform: '' # initialTransform
                               # [initialTransform,<useInverse>]
                               # [fixedImage,movingImage,initializationFeature]
                               # Specify the initial moving transform(s) which get immediately incorporated into 
                               # the composite transform. The order of the transforms is stack-esque in that the 
                               # last transform specified on the command line is the first to be applied. In 
                               # addition to initialization with ITK transforms, the user can perform an initial 
                               # translation alignment by specifying the fixed and moving images and selecting an 
                               # initialization feature. These features include using the geometric center of the 
                               # images (=0), the image intensities (=1), or the origin of the images (=2). 
  metric: '' # CC[fixedImage,movingImage,metricWeight,radius,<samplingStrategy={None,Regular,Random}>,<samplingPercentage=[0,1]>]
             # MI[fixedImage,movingImage,metricWeight,numberOfBins,<samplingStrategy={None,Regular,Random}>,<samplingPercentage=[0,1]>]
             # Mattes[fixedImage,movingImage,metricWeight,numberOfBins,<samplingStrategy={None,Regular,Random}>,<samplingPercentage=[0,1]>]
             # MeanSquares[fixedImage,movingImage,metricWeight,radius=NA,<samplingStrategy={None,Regular,Random}>,<samplingPercentage=[0,1]>]
             # Demons[fixedImage,movingImage,metricWeight,radius=NA,<samplingStrategy={None,Regular,Random}>,<samplingPercentage=[0,1]>]
             # GC[fixedImage,movingImage,metricWeight,radius=NA,<samplingStrategy={None,Regular,Random}>,<samplingPercentage=[0,1]>]
             # ICP[fixedPointSet,movingPointSet,metricWeight,<samplingPercentage=[0,1]>,<boundaryPointsOnly=0>]
             # PSE[fixedPointSet,movingPointSet,metricWeight,<samplingPercentage=[0,1]>,<boundaryPointsOnly=0>,<pointSetSigma=1>,<kNeighborhood=50>]
             # JHCT[fixedPointSet,movingPointSet,metricWeight,<samplingPercentage=[0,1]>,<boundaryPointsOnly=0>,<pointSetSigma=1>,<kNeighborhood=50>,<alpha=1.1>,<useAnisotropicCovariances=1>]
             # These image metrics are available--- CC: ANTS neighborhood cross correlation, 
             # MI: Mutual information, Demons: (Thirion), MeanSquares, and GC: Global 
             # Correlation. The "metricWeight" variable is used to modulate the per stage 
             # weighting of the metrics. The metrics can also employ a sampling strategy 
             # defined by a sampling percentage. The sampling strategy defaults to 'None' (aka 
             # a dense sampling of one sample per voxel), otherwise it defines a point set over 
             # which to optimize the metric. The point set can be on a regular lattice or a 
             # random lattice of points slightly perturbed to minimize aliasing artifacts. 
             # samplingPercentage defines the fraction of points to select from the domain. In 
             # addition, three point set metrics are available: Euclidean (ICP), Point-set 
             # expectation (PSE), and Jensen-Havrda-Charvet-Tsallis (JHCT). 
  transform: '' # Rigid[gradientStep]
                # Affine[gradientStep]
                # CompositeAffine[gradientStep]
                # Similarity[gradientStep]
                # Translation[gradientStep]
                # BSpline[gradientStep,meshSizeAtBaseLevel]
                # GaussianDisplacementField[gradientStep,updateFieldVarianceInVoxelSpace,totalFieldVarianceInVoxelSpace]
                # BSplineDisplacementField[gradientStep,updateFieldMeshSizeAtBaseLevel,totalFieldMeshSizeAtBaseLevel,<splineOrder=3>]
                # TimeVaryingVelocityField[gradientStep,numberOfTimeIndices,updateFieldVarianceInVoxelSpace,updateFieldTimeVariance,totalFieldVarianceInVoxelSpace,totalFieldTimeVariance]
                # TimeVaryingBSplineVelocityField[gradientStep,velocityFieldMeshSize,<numberOfTimePointSamples=4>,<splineOrder=3>]
                # SyN[gradientStep,updateFieldVarianceInVoxelSpace,totalFieldVarianceInVoxelSpace]
                # BSplineSyN[gradientStep,updateFieldMeshSizeAtBaseLevel,totalFieldMeshSizeAtBaseLevel,<splineOrder=3>]
                # Exponential[gradientStep,updateFieldVarianceInVoxelSpace,velocityFieldVarianceInVoxelSpace,<numberOfIntegrationSteps>]
                # BSplineExponential[gradientStep,updateFieldMeshSizeAtBaseLevel,velocityFieldMeshSizeAtBaseLevel,<numberOfIntegrationSteps>,<splineOrder=3>]
                # Several transform options are available. The gradientStep or learningRate 
                # characterizes the gradient descent optimization and is scaled appropriately for 
                # each transform using the shift scales estimator. Subsequent parameters are 
                # transform-specific and can be determined from the usage. For the B-spline 
                # transforms one can also specify the smoothing in terms of spline distance (i.e. 
                # knot spacing). 
  convergence: '' # MxNxO
                  # [MxNxO,<convergenceThreshold=1e-6>,<convergenceWindowSize=10>]
                  # Convergence is determined from the number of iterations per level and is 
                  # determined by fitting a line to the normalized energy profile of the last N 
                  # iterations (where N is specified by the window size) and determining the slope 
                  # which is then compared with the convergence threshold. 
  smoothing-sigmas: '' # MxNxO...
                       # Specify the sigma of gaussian smoothing at each level. Units are given in terms 
                       # of voxels ('vox') or physical spacing ('mm'). Example usage is '4x2x1mm' and 
                       # '4x2x1vox' where no units implies voxel spacing. 
  shrink-factors: '' # MxNxO...
                     # Specify the shrink factor for the virtual domain (typically the fixed image) at 
                     # each level. 
  use-histogram-matching: '' # Histogram match the images before registration. 
  use-estimate-learning-rate-once: '' # 
                                      # turn on the option that lets you estimate the learning rate step size only at 
                                      # the beginning of each level. * useful as a second stage of fine-scale 
                                      # registration. 
  winsorize-image-intensities: '' # [lowerQuantile,upperQuantile]
                                  # Winsorize data based on specified quantiles. 
  masks: '' # [fixedImageMask,movingImageMask]
            # Image masks to limit voxels considered by the metric. 
  float: '' # 
            # Use 'float' instead of 'double' for computations. 
            # <VALUES>: 0
  h: '' # Print the help menu (short version). 
  help: '' # Print the help menu. Will also print values used on the current command line call. 
