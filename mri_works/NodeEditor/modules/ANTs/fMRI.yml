antsMotionCorr:
  dimensionality: 3 # 2/3 This option forces the image to be treated as a specified-dimensional image. If not specified, the program tries to infer the dimensionality from the input image.
  use-estimate-learning-rate-once: True # turn  on  the option that lets you estimate the learning rate step size only at the beginning of each level. * useful as a second stage of fine-scale registration.
  n-images: 10  # This option sets the number of images to use to construct the template image.
  metric: '' # CC[fixedImage,movingImage,metricWeight,radius,<samplingStrategy={Regular,Random}>,<samplingPercentage=[0,1]>]
             # MI[fixedImage,movingImage,metricWeight,numberOfBins,<samplingStrategy={Regular,Random}>,<samplingPercentage=[0,1]>]
             # Demons[fixedImage,movingImage,metricWeight,radius,<samplingStrategy={Regular,Random}>,<samplingPercentage=[0,1]>]
             # GC[fixedImage,movingImage,metricWeight,radius,<samplingStrategy={Regular,Random}>,<samplingPercentage=[0,1]>]
             # Four  image metrics are available--- GC : global correlation, CC: ANTS neighborhood
             # cross correlation, MI: Mutual information, and Demons: Thirion's  Demons  (modified
             # mean-squares).  Note  that  the metricWeight is currently not used. Rather, it is a
             # temporary place holder until multivariate metrics are available for a single stage.
             # The  fixed image should be a single time point (eg the average of the time series).
             # By default, this image is not used, the fixed image for correction of  each  volume
             # is  the  preceding  volume  in  the time series.  See below for the option to use a
             # fixed reference image for all volumes.
  useFixedReferenceImage: 1 #  use a fixed reference image to correct all  volumes,  instead  of  correcting  each image to the prior volume in the time series.
  useScalesEstimator: 1 # use the scale estimator to control optimization.
  transform: 'Rigid[0.05]' # Affine[gradientStep]
                           # Rigid[gradientStep]
                           # GaussianDisplacementField[gradientStep,updateFieldSigmaInPhysicalSpace,totalFieldSigmaInPhysicalSpace]
                           # SyN[gradientStep,updateFieldSigmaInPhysicalSpace,totalFieldSigmaInPhysicalSpace]
                           # Several transform options are available. The gradientStep orlearningRate 
                           # characterizes the gradient descent optimization and is scaled appropriately for 
                           # each transform using the shift scales estimator. Subsequent parameters are 
                           # transform-specific and can be determined from the usage.
  iterations: '45x45x45' # MxNx0... Specify the number of iterations at each level.
  smoothingSigmas: '4x2x0' # MxNx0... Specify the amount of smoothing at each level.
  shrinkFactors: '4x2x1' # MxNx0... Specify the shrink factor for the virtual domain (typically the fixed image) at each level.
  output: ['path'] # [outputTransformPrefix,<outputWarpedImage>,<outputAverageImage>] 
                   # Specify the output transform prefix (output format is .nii.gz ).Optionally, one 
                   # can choose to warp the moving image to the fixed space and, if the inverse 
                   # transform exists, one can also output the warped fixed image.
  average-image: 0.0 # Average the input time series image.
  write-displacement: True # Write the low-dimensional 3D transforms to a 4D displacement field
  